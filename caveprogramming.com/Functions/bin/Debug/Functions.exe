
   return TEST_COMPLETED;
}

/**
 * @brief Tests opening from memory.
 *
 * \sa http://wiki.libsdl.org/SDL_RWFromMem
 * \sa http://wiki.libsdl.org/SDL_RWClose
 */
int
rwops_testMem (void)
{
   char mem[sizeof(RWopsHelloWorldTestString)];
   SDL_RWops *rw;
   int result;

   /* Clear buffer */
   SDL_zeroa(mem);

   /* Open */
   rw = SDL_RWFromMem(mem, sizeof(RWopsHelloWorldTestString)-1);
   SDLTest_AssertPass("Call to SDL_RWFromMem() succeeded");
   SDLTest_AssertCheck(rw != NULL, "Verify opening memory with SDL_RWFromMem does not return NULL");

   /* Bail out if NULL */
   if (rw == NULL) return TEST_ABORTED;

   /* Check type */
   SDLTest_AssertCheck(rw->type == SDL_RWOPS_MEMORY, "Verify RWops type is SDL_RWOPS_MEMORY; expected: %d, got: %d", SDL_RWOPS_MEMORY, rw->type);

   /* Run generic tests */
   _testGenericRWopsValidations(rw, 1);

   /* Close */
   result = SDL_RWclose(rw);
   SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
   SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

   return TEST_COMPLETED;
}


/**
 * @brief Tests opening from memory.
 *
 * \sa
 * http://wiki.libsdl.org/SDL_RWFromConstMem
 * http://wiki.libsdl.org/SDL_RWClose
 */
int
rwops_testConstMem (void)
{
   SDL_RWops *rw;
   int result;

   /* Open handle */
   rw = SDL_RWFromConstMem( RWopsHelloWorldCompString, sizeof(RWopsHelloWorldCompString)-1 );
   SDLTest_AssertPass("Call to SDL_RWFromConstMem() succeeded");
   SDLTest_AssertCheck(rw != NULL, "Verify opening memory with SDL_RWFromConstMem does not return NULL");

   /* Bail out if NULL */
   if (rw == NULL) return TEST_ABORTED;

   /* Check type */
   SDLTest_AssertCheck(rw->type == SDL_RWOPS_MEMORY_RO, "Verify RWops type is SDL_RWOPS_MEMORY_RO; expected: %d, got: %d", SDL_RWOPS_MEMORY_RO, rw->type);

   /* Run generic tests */
   _testGenericRWopsValidations( rw, 0 );

   /* Close handle */
   result = SDL_RWclose(rw);
   SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
   SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

  return TEST_COMPLETED;
}


/**
 * @brief Tests reading from file.
 *
 * \sa
 * http://wiki.libsdl.org/SDL_RWFromFile
 * http://wiki.libsdl.org/SDL_RWClose
 */
int
rwops_testFileRead(void)
{
   SDL_RWops *rw;
   int result;

   /* Read test. */
   rw = SDL_RWFromFile(RWopsReadTestFilename, "r");
   SDLTest_AssertPass("Call to SDL_RWFromFile(..,\"r\") succeeded");
   SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFile in read mode does not return NULL");

   /* Bail out if NULL */
   if (rw == NULL) return TEST_ABORTED;

   /* Check type */
#if defined(__ANDROID__)
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_STDFILE || rw->type == SDL_RWOPS_JNIFILE,
      "Verify RWops type is SDL_RWOPS_STDFILE or SDL_RWOPS_JNIFILE; expected: %d|%d, got: %d", SDL_RWOPS_STDFILE, SDL_RWOPS_JNIFILE, rw->type);
#elif defined(__WIN32__)
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_WINFILE,
      "Verify RWops type is SDL_RWOPS_WINFILE; expected: %d, got: %d", SDL_RWOPS_WINFILE, rw->type);
#else
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_STDFILE,
      "Verify RWops type is SDL_RWOPS_STDFILE; expected: %d, got: %d", SDL_RWOPS_STDFILE, rw->type);
#endif

   /* Run generic tests */
   _testGenericRWopsValidations( rw, 0 );

   /* Close handle */
   result = SDL_RWclose(rw);
   SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
   SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

   return TEST_COMPLETED;
}

/**
 * @brief Tests writing from file.
 *
 * \sa
 * http://wiki.libsdl.org/SDL_RWFromFile
 * http://wiki.libsdl.org/SDL_RWClose
 */
int
rwops_testFileWrite(void)
{
   SDL_RWops *rw;
   int result;

   /* Write test. */
   rw = SDL_RWFromFile(RWopsWriteTestFilename, "w+");
   SDLTest_AssertPass("Call to SDL_RWFromFile(..,\"w+\") succeeded");
   SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFile in write mode does not return NULL");

   /* Bail out if NULL */
   if (rw == NULL) return TEST_ABORTED;

   /* Check type */
#if defined(__ANDROID__)
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_STDFILE || rw->type == SDL_RWOPS_JNIFILE,
      "Verify RWops type is SDL_RWOPS_STDFILE or SDL_RWOPS_JNIFILE; expected: %d|%d, got: %d", SDL_RWOPS_STDFILE, SDL_RWOPS_JNIFILE, rw->type);
#elif defined(__WIN32__)
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_WINFILE,
      "Verify RWops type is SDL_RWOPS_WINFILE; expected: %d, got: %d", SDL_RWOPS_WINFILE, rw->type);
#else
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_STDFILE,
      "Verify RWops type is SDL_RWOPS_STDFILE; expected: %d, got: %d", SDL_RWOPS_STDFILE, rw->type);
#endif

   /* Run generic tests */
   _testGenericRWopsValidations( rw, 1 );

   /* Close handle */
   result = SDL_RWclose(rw);
   SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
   SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

   return TEST_COMPLETED;
}


/**
 * @brief Tests reading from file handle
 *
 * \sa
 * http://wiki.libsdl.org/SDL_RWFromFP
 * http://wiki.libsdl.org/SDL_RWClose
 *
 */
int
rwops_testFPRead(void)
{
   FILE *fp;
   SDL_RWops *rw;
   int result;

   /* Run read tests. */
   fp = fopen(RWopsReadTestFilename, "r");
   SDLTest_AssertCheck(fp != NULL, "Verify handle from opening file '%s' in read mode is not NULL", RWopsReadTestFilename);

   /* Bail out if NULL */
   if (fp == NULL) return TEST_ABORTED;

   /* Open */
   rw = SDL_RWFromFP( fp, SDL_TRUE );
   SDLTest_AssertPass("Call to SDL_RWFromFP() succeeded");
   SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFP in read mode does not return NULL");

   /* Bail out if NULL */
   if (rw == NULL) {
     fclose(fp);
     return TEST_ABORTED;
   }

   /* Check type */
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_STDFILE,
      "Verify RWops type is SDL_RWOPS_STDFILE; expected: %d, got: %d", SDL_RWOPS_STDFILE, rw->type);

   /* Run generic tests */
   _testGenericRWopsValidations( rw, 0 );

   /* Close handle - does fclose() */
   result = SDL_RWclose(rw);
   SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
   SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

   return TEST_COMPLETED;
}


/**
 * @brief Tests writing to file handle
 *
 * \sa
 * http://wiki.libsdl.org/SDL_RWFromFP
 * http://wiki.libsdl.org/SDL_RWClose
 *
 */
int
rwops_testFPWrite(void)
{
   FILE *fp;
   SDL_RWops *rw;
   int result;

   /* Run write tests. */
   fp = fopen(RWopsWriteTestFilename, "w+");
   SDLTest_AssertCheck(fp != NULL, "Verify handle from opening file '%s' in write mode is not NULL", RWopsWriteTestFilename);

   /* Bail out if NULL */
   if (fp == NULL) return TEST_ABORTED;

   /* Open */
   rw = SDL_RWFromFP( fp, SDL_TRUE );
   SDLTest_AssertPass("Call to SDL_RWFromFP() succeeded");
   SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFP in write mode does not return NULL");

   /* Bail out if NULL */
   if (rw == NULL) {
     fclose(fp);
     return TEST_ABORTED;
   }

   /* Check type */
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_STDFILE,
      "Verify RWops type is SDL_RWOPS_STDFILE; expected: %d, got: %d", SDL_RWOPS_STDFILE, rw->type);

   /* Run generic tests */
   _testGenericRWopsValidations( rw, 1 );

   /* Close handle - does fclose() */
   result = SDL_RWclose(rw);
   SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
   SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

   return TEST_COMPLETED;
}

/**
 * @brief Tests alloc and free RW context.
 *
 * \sa http://wiki.libsdl.org/SDL_AllocRW
 * \sa http://wiki.libsdl.org/SDL_FreeRW
 */
int
rwops_testAllocFree (void)
{
   /* Allocate context */
   SDL_RWops *rw = SDL_AllocRW();
   SDLTest_AssertPass("Call to SDL_AllocRW() succeeded");
   SDLTest_AssertCheck(rw != NULL, "Validate result from SDL_AllocRW() is not NULL");
   if (rw==NULL) return TEST_ABORTED;

   /* Check type */
   SDLTest_AssertCheck(
      rw->type == SDL_RWOPS_UNKNOWN,
      "Verify RWops type is SDL_RWOPS_UNKNOWN; expected: %d, got: %d", SDL_RWOPS_UNKNOWN, rw->type);

   /* Free context again */
   SDL_FreeRW(rw);
   SDLTest_AssertPass("Call to SDL_FreeRW() succeeded");

   return TEST_COMPLETED;
}

/**
 * @brief Compare memory and file reads
 *
 * \sa http://wiki.libsdl.org/SDL_RWFromMem
 * \sa http://wiki.libsdl.org/SDL_RWFromFile
 */
int
rwops_testCompareRWFromMemWithRWFromFile(void)
{
   int slen = 26;
   char buffer_file[27];
   char buffer_mem[27];
   size_t rv_file;
   size_t rv_mem;
   Uint64 sv_file;
   Uint64 sv_mem;
   SDL_RWops* rwops_file;
   SDL_RWops* rwops_mem;
   int size;
   int result;


   for (size=5; size<10; size++)
   {
     /* Terminate buffer */
     buffer_file[slen] = 0;
     buffer_mem[slen] = 0;

     /* Read/seek from memory */
     rwops_mem = SDL_RWFromMem((void *)RWopsAlphabetString, slen);
     SDLTest_AssertPass("Call to SDL_RWFromMem()");
     rv_mem = SDL_RWread(rwops_mem, buffer_mem, size, 6);
     SDLTest_AssertPass("Call to SDL_RWread(mem, size=%d)", size);
     sv_mem = SDL_RWseek(rwops_mem, 0, SEEK_END);
     SDLTest_AssertPass("Call to SDL_RWseek(mem,SEEK_END)");
     result = SDL_RWclose(rwops_mem);
     SDLTest_AssertPass("Call to SDL_RWclose(mem)");
     SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

     /* Read/see from file */
     rwops_file = SDL_RWFromFile(RWopsAlphabetFilename, "r");
     SDLTest_AssertPass("Call to SDL_RWFromFile()");
     rv_file = SDL_RWread(rwops_file, buffer_file, size, 6);
     SDLTest_AssertPass("Call to SDL_RWread(file, size=%d)", size);
     sv_file = SDL_RWseek(rwops_file, 0, SEEK_END);
     SDLTest_AssertPass("Call to SDL_RWseek(file,SEEK_END)");
     result = SDL_RWclose(rwops_file);
     SDLTest_AssertPass("Call to SDL_RWclose(file)");
     SDLTest_AssertCheck(result == 0, "Verify result value is 0; got: %d", result);

     /* Compare */
     SDLTest_AssertCheck(rv_mem == rv_file, "Verify returned read blocks matches for mem and file reads; got: rv_mem=%d rv_file=%d", (int) rv_mem, (int) rv_file);
     SDLTest_AssertCheck(sv_mem == sv_file, "Verify SEEK_END position matches for mem and file seeks; got: sv_mem=%d sv_file=%d", (int) sv_mem, (int) sv_file);
     SDLTest_AssertCheck(buffer_mem[slen] == 0, "Verify mem buffer termination; expected: 0, got: %d", buffer_mem[slen]);
     SDLTest_AssertCheck(buffer_file[slen] == 0, "Verify file buffer termination; expected: 0, got: %d", buffer_file[slen]);
     SDLTest_AssertCheck(
       SDL_strncmp(buffer_mem, RWopsAlphabetString, slen) == 0,
       "Verify mem buffer contain alphabet string; expected: %s, got: %s", RWopsAlphabetString, buffer_mem);
     SDLTest_AssertCheck(
       SDL_strncmp(buffer_file, RWopsAlphabetString, slen) == 0,
       "Verify file buffer contain alphabet string; expected: %s, got: %s", RWopsAlphabetString, buffer_file);
   }

   return TEST_COMPLETED;
}

/**
 * @brief Tests writing and reading from file using endian aware functions.
 *
 * \sa
 * http://wiki.libsdl.org/SDL_RWFromFile
 * http://wiki.libsdl.org/SDL_RWClose
 * http://wiki.libsdl.org/SDL_ReadBE16
 * http://wiki.libsdl.org/SDL_WriteBE16
 */
int
rwops_testFileWriteReadEndian(void)
{
   SDL_RWops *rw;
   Sint64 result;
   int mode;
   size_t objectsWritten;
   Uint16 BE16value;
   Uint32 BE32value;
   Uint64 BE64value;
   Uint16 LE16value;
   Uint32 LE32value;
   Uint64 LE64value;
   Uint16 BE16test;
   Uint32 BE32test;
   Uint64 BE64test;
   Uint16 LE16test;
   Uint32 LE32test;
   Uint64 LE64test;
   int cresult;

   for (mode = 0; mode < 3; mode++) {

     /* Create test data */
     switch (mode) {
       case 0:
        SDLTest_Log("All 0 values");
        BE16value = 0;
        BE32value = 0;
        BE64value = 0;
        LE16value = 0;
        LE32value = 0;
        LE64value = 0;
        break;
       case 1:
        SDLTest_Log("All 1 values");
        BE16value = 1;
        BE32value = 1;
        BE64value = 1;
        LE16value = 1;
        LE32value = 1;
        LE64value = 1;
        break;
       case 2:
        SDLTest_Log("Random values");
        BE16value = SDLTest_RandomUint16();
        BE32value = SDLTest_RandomUint32();
        BE64value = SDLTest_RandomUint64();
        LE16value = SDLTest_RandomUint16();
        LE32value = SDLTest_RandomUint32();
        LE64value = SDLTest_RandomUint64();
        break;
     }

     /* Write test. */
     rw = SDL_RWFromFile(RWopsWriteTestFilename, "w+");
     SDLTest_AssertPass("Call to SDL_RWFromFile(..,\"w+\")");
     SDLTest_AssertCheck(rw != NULL, "Verify opening file with SDL_RWFromFile in write mode does not return NULL");

     /* Bail out if NULL */
     if (rw == NULL) return TEST_ABORTED;

     /* Write test data */
     objectsWritten = SDL_WriteBE16(rw, BE16value);
     SDLTest_AssertPass("Call to SDL_WriteBE16()");
     SDLTest_AssertCheck(objectsWritten == 1, "Validate number of objects written, expected: 1, got: %i", (int) objectsWritten);
     objectsWritten = SDL_WriteBE32(rw, BE32value);
     SDLTest_AssertPass("Call to SDL_WriteBE32()");
     SDLTest_AssertCheck(objectsWritten == 1, "Validate number of objects written, expected: 1, got: %i", (int) objectsWritten);
     objectsWritten = SDL_WriteBE64(rw, BE64value);
     SDLTest_AssertPass("Call to SDL_WriteBE64()");
     SDLTest_AssertCheck(objectsWritten == 1, "Validate number of objects written, expected: 1, got: %i", (int) objectsWritten);
     objectsWritten = SDL_WriteLE16(rw, LE16value);
     SDLTest_AssertPass("Call to SDL_WriteLE16()");
     SDLTest_AssertCheck(objectsWritten == 1, "Validate number of objects written, expected: 1, got: %i", (int) objectsWritten);
     objectsWritten = SDL_WriteLE32(rw, LE32value);
     SDLTest_AssertPass("Call to SDL_WriteLE32()");
     SDLTest_AssertCheck(objectsWritten == 1, "Validate number of objects written, expected: 1, got: %i", (int) objectsWritten);
     objectsWritten = SDL_WriteLE64(rw, LE64value);
     SDLTest_AssertPass("Call to SDL_WriteLE64()");
     SDLTest_AssertCheck(objectsWritten == 1, "Validate number of objects written, expected: 1, got: %i", (int) objectsWritten);

     /* Test seek to start */
     result = SDL_RWseek( rw, 0, RW_SEEK_SET );
     SDLTest_AssertPass("Call to SDL_RWseek succeeded");
     SDLTest_AssertCheck(result == 0, "Verify result from position 0 with SDL_RWseek, expected 0, got %i", (int) result);

     /* Read test data */
     BE16test = SDL_ReadBE16(rw);
     SDLTest_AssertPass("Call to SDL_ReadBE16()");
     SDLTest_AssertCheck(BE16test == BE16value, "Validate return value from SDL_ReadBE16, expected: %hu, got: %hu", BE16value, BE16test);
     BE32test = SDL_ReadBE32(rw);
     SDLTest_AssertPass("Call to SDL_ReadBE32()");
     SDLTest_AssertCheck(BE32test == BE32value, "Validate return value from SDL_ReadBE32, expected: %u, got: %u", BE32value, BE32test);
     BE64test = SDL_ReadBE64(rw);
     SDLTest_AssertPass("Call to SDL_ReadBE64()");
     SDLTest_AssertCheck(BE64test == BE64value, "Validate return value from SDL_ReadBE64, expected: %"SDL_PRIu64", got: %"SDL_PRIu64, BE64value, BE64test);
     LE16test = SDL_ReadLE16(rw);
     SDLTest_AssertPass("Call to SDL_ReadLE16()");
     SDLTest_AssertCheck(LE16test == LE16value, "Validate return value from SDL_ReadLE16, expected: %hu, got: %hu", LE16value, LE16test);
     LE32test = SDL_ReadLE32(rw);
     SDLTest_AssertPass("Call to SDL_ReadLE32()");
     SDLTest_AssertCheck(LE32test == LE32value, "Validate return value from SDL_ReadLE32, expected: %u, got: %u", LE32value, LE32test);
     LE64test = SDL_ReadLE64(rw);
     SDLTest_AssertPass("Call to SDL_ReadLE64()");
     SDLTest_AssertCheck(LE64test == LE64value, "Validate return value from SDL_ReadLE64, expected: %"SDL_PRIu64", got: %"SDL_PRIu64, LE64value, LE64test);

     /* Close handle */
     cresult = SDL_RWclose(rw);
     SDLTest_AssertPass("Call to SDL_RWclose() succeeded");
     SDLTest_AssertCheck(cresult == 0, "Verify result value is 0; got: %d", cresult);
   }

   return TEST_COMPLETED;
}


/* ================= Test References ================== */

/* RWops test cases */
static const SDLTest_TestCaseReference rwopsTest1 =
        { (SDLTest_TestCaseFp)rwops_testParamNegative, "rwops_testParamNegative", "Negative test for SDL_RWFromFile parameters", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest2 =
        { (SDLTest_TestCaseFp)rwops_testMem, "rwops_testMem", "Tests opening from memory", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest3 =
        { (SDLTest_TestCaseFp)rwops_testConstMem, "rwops_testConstMem", "Tests opening from (const) memory", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest4 =
        { (SDLTest_TestCaseFp)rwops_testFileRead, "rwops_testFileRead", "Tests reading from a file", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest5 =
        { (SDLTest_TestCaseFp)rwops_testFileWrite, "rwops_testFileWrite", "Test writing to a file", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest6 =
        { (SDLTest_TestCaseFp)rwops_testFPRead, "rwops_testFPRead", "Test reading from file pointer", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest7 =
        { (SDLTest_TestCaseFp)rwops_testFPWrite, "rwops_testFPWrite", "Test writing to file pointer", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest8 =
        { (SDLTest_TestCaseFp)rwops_testAllocFree, "rwops_testAllocFree", "Test alloc and free of RW context", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest9 =
        { (SDLTest_TestCaseFp)rwops_testFileWriteReadEndian, "rwops_testFileWriteReadEndian", "Test writing and reading via the Endian aware functions", TEST_ENABLED };

static const SDLTest_TestCaseReference rwopsTest10 =
        { (SDLTest_TestCaseFp)rwops_testCompareRWFromMemWithRWFromFile, "rwops_testCompareRWFromMemWithRWFromFile", "Compare RWFromMem and RWFromFile RWops for read and seek", TEST_ENABLED };

/* Sequence of RWops test cases */
static const SDLTest_TestCaseReference *rwopsTests[] =  {
    &rwopsTest1, &rwopsTest2, &rwopsTest3, &rwopsTest4, &rwopsTest5, &rwopsTest6,
    &rwopsTest7, &rwopsTest8, &rwopsTest9, &rwopsTest10, NULL
};

/* RWops test suite (global) */
SDLTest_TestSuiteReference rwopsTestSuite = {
    "RWops",
    RWopsSetUp,
    rwopsTests,
    RWopsTearDown
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /**
 * SDL_test test suite
 */

#include <limits.h>
/* Visual Studio 2008 doesn't have stdint.h */
#if defined(_MSC_VER) && _MSC_VER <= 1500
#define UINT8_MAX   _UI8_MAX
#define UINT16_MAX  _UI16_MAX
#define UINT32_MAX  _UI32_MAX
#define INT64_MIN    _I64_MIN
#define INT64_MAX    _I64_MAX
#define UINT64_MAX  _UI64_MAX
#else
#include <stdint.h>
#endif

#include <stdio.h>
#include <float.h>
#include <ctype.h>

#include "SDL.h"
#include "SDL_test.h"

/* Test case functions */

/* Forward declarations for internal harness functions */
extern char *SDLTest_GenerateRunSeed(const int length);

/**
 * @brief Calls to SDLTest_GenerateRunSeed()
 */
int
sdltest_generateRunSeed(void *arg)
{
  char* result;
  size_t i, l;
  int j;
  
  for (i = 1; i <= 10; i += 3) {   
     result = SDLTest_GenerateRunSeed((const int)i);
     SDLTest_AssertPass("Call to SDLTest_GenerateRunSeed()");
     SDLTest_AssertCheck(result != NULL, "Verify returned value is not NULL");
     if (result != NULL) {
       l = SDL_strlen(result);
       SDLTest_AssertCheck(l == i, "Verify length of returned value is %d, got: %d", (int) i, (int) l);
       SDL_free(result);
     }
  }

  /* Negative cases */
  for (j = -2; j <= 0; j++) {
     result = SDLTest_GenerateRunSeed((const int)j);
     SDLTest_AssertPass("Call to SDLTest_GenerateRunSeed()");
     SDLTest_AssertCheck(result == NULL, "Verify returned value is not NULL");
  }
  
  return TEST_COMPLETED;
}

/**
 * @brief Calls to SDLTest_GetFuzzerInvocationCount()
 */
int
sdltest_getFuzzerInvocationCount(void *arg)
{
  Uint8 result;
  int fuzzerCount1, fuzzerCount2;

  fuzzerCount1 = SDLTest_GetFuzzerInvocationCount();
  SDLTest_AssertPass("Call to SDLTest_GetFuzzerInvocationCount()");
  SDLTest_AssertCheck(fuzzerCount1 >= 0, "Verify returned value, expected: >=0, got: %d", fuzzerCount1);

  result = SDLTest_RandomUint8();
  SDLTest_AssertPass("Call to SDLTest_RandomUint8(), returned %d", result);

  fuzzerCount2 = SDLTest_GetFuzzerInvocationCount();
  SDLTest_AssertPass("Call to SDLTest_GetFuzzerInvocationCount()");
  SDLTest_AssertCheck(fuzzerCount2 > fuzzerCount1, "Verify returned value, expected: >%d, got: %d", fuzzerCount1, fuzzerCount2);

  return TEST_COMPLETED;
}


/**
 * @brief Calls to random number generators
 */
int
sdltest_randomNumber(void *arg)
{
  Sint64 result;
  double dresult;
  Uint64 umax;
  Sint64 min, max;

  result = (Sint64)SDLTest_RandomUint8();
  umax = (1 << 8) - 1;
  SDLTest_AssertPass("Call to SDLTest_RandomUint8");
  SDLTest_AssertCheck(result >= 0 && result <= (Sint64)umax, "Verify result value, expected: [0,%"SDL_PRIu64"], got: %"SDL_PRIs64, umax, result);

  result = (Sint64)SDLTest_RandomSint8();
  min = 0 - (1 << 7);
  max =     (1 << 7) - 1;
  SDLTest_AssertPass("Call to SDLTest_RandomSint8");
  SDLTest_AssertCheck(result >= min && result <= max, "Verify result value, expected: [%"SDL_PRIs64",%"SDL_PRIs64"], got: %"SDL_PRIs64, min, max, result);

  result = (Sint64)SDLTest_RandomUint16();
  umax = (1 << 16) - 1;
  SDLTest_AssertPass("Call to SDLTest_RandomUint16");
  SDLTest_AssertCheck(result >= 0 && result <= (Sint64)umax, "Verify result value, expected: [0,%"SDL_PRIu64"], got: %"SDL_PRIs64, umax, result);

  result = (Sint64)SDLTest_RandomSint16();
  min = 0 - (1 << 15);
  max =     (1 << 15) - 1;
  SDLTest_AssertPass("Call to SDLTest_RandomSint16");
  SDLTest_AssertCheck(result >= min && result <= max, "Verify result value, expected: [%"SDL_PRIs64",%"SDL_PRIs64"], got: %"SDL_PRIs64, min, max, result);

  result = (Sint64)SDLTest_RandomUint32();
  umax = ((Uint64)1 << 32) - 1;
  SDLTest_AssertPass("Call to SDLTest_RandomUint32");
  SDLTest_AssertCheck(result >= 0 && result <= (Sint64)umax, "Verify result value, expected: [0,%"SDL_PRIu64"], got: %"SDL_PRIs64, umax, result);

  result = (Sint64)SDLTest_RandomSint32();
  min = 0 - ((Sint64)1 << 31);
  max =     ((Sint64)1 << 31) - 1;
  SDLTest_AssertPass("Call to SDLTest_RandomSint32");
  SDLTest_AssertCheck(result >= min && result <= max, "Verify result value, expected: [%"SDL_PRIs64",%"SDL_PRIs64"], got: %"SDL_PRIs64, min, max, result);

  SDLTest_RandomUint64();
  SDLTest_AssertPass("Call to SDLTest_RandomUint64");

  result = SDLTest_RandomSint64();
  SDLTest_AssertPass("Call to SDLTest_RandomSint64");

  dresult = (double)SDLTest_RandomUnitFloat();
  SDLTest_AssertPass("Call to SDLTest_RandomUnitFloat");
  SDLTest_AssertCheck(dresult >= 0.0 && dresult < 1.0, "Verify result value, expected: [0.0,1.0[, got: %e", dresult);

  dresult = (double)SDLTest_RandomFloat();
  SDLTest_AssertPass("Call to SDLTest_RandomFloat");
  SDLTest_AssertCheck(dresult >= (double)(-FLT_MAX) && dresult <= (double)FLT_MAX, "Verify result value, expected: [%e,%e], got: %e", (double)(-FLT_MAX), (double)FLT_MAX, dresult);

  dresult = (double)SDLTest_RandomUnitDouble();
  SDLTest_AssertPass("Call to SDLTest_RandomUnitDouble");
  SDLTest_AssertCheck(dresult >= 0.0 && dresult < 1.0, "Verify result value, expected: [0.0,1.0[, got: %e", dresult);

  dresult = SDLTest_RandomDouble();
  SDLTest_AssertPass("Call to SDLTest_RandomDouble");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Uint8
 */
int
sdltest_randomBoundaryNumberUint8(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Uint64 uresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomUintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12 || uresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0 || uresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(0, 99, SDL_FALSE) returns 100 */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(0, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 100,
    "Validate result value for parameters (0,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 0xff, SDL_FALSE) returns 0 (no error) */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(1, 255, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters (1,255,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xfe, SDL_FALSE) returns 0xff (no error) */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(0, 254, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0xff,
    "Validate result value for parameters (0,254,SDL_FALSE); expected: 0xff, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xff, SDL_FALSE) returns 0 (sets error) */
  uresult = (Uint64)SDLTest_RandomUint8BoundaryValue(0, 255, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint8BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters(0,255,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Uint16
 */
int
sdltest_randomBoundaryNumberUint16(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Uint64 uresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomUintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12 || uresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0 || uresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(0, 99, SDL_FALSE) returns 100 */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(0, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 100,
    "Validate result value for parameters (0,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 0xffff, SDL_FALSE) returns 0 (no error) */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(1, 0xffff, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters (1,0xffff,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xfffe, SDL_FALSE) returns 0xffff (no error) */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(0, 0xfffe, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0xffff,
    "Validate result value for parameters (0,0xfffe,SDL_FALSE); expected: 0xffff, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xffff, SDL_FALSE) returns 0 (sets error) */
  uresult = (Uint64)SDLTest_RandomUint16BoundaryValue(0, 0xffff, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint16BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters(0,0xffff,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Uint32
 */
int
sdltest_randomBoundaryNumberUint32(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Uint64 uresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomUintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12 || uresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0 || uresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(0, 99, SDL_FALSE) returns 100 */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(0, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 100,
    "Validate result value for parameters (0,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 0xffffffff, SDL_FALSE) returns 0 (no error) */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(1, 0xffffffff, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters (1,0xffffffff,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xfffffffe, SDL_FALSE) returns 0xffffffff (no error) */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(0, 0xfffffffe, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0xffffffff,
    "Validate result value for parameters (0,0xfffffffe,SDL_FALSE); expected: 0xffffffff, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xffffffff, SDL_FALSE) returns 0 (sets error) */
  uresult = (Uint64)SDLTest_RandomUint32BoundaryValue(0, 0xffffffff, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint32BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters(0,0xffffffff,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Uint64
 */
int
sdltest_randomBoundaryNumberUint64(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Uint64 uresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomUintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 12 || uresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 10 || uresult == 11 || uresult == 19 || uresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0 || uresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(0, 99, SDL_FALSE) returns 100 */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(0, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 100,
    "Validate result value for parameters (0,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, uresult);

  /* RandomUintXBoundaryValue(1, 0xffffffffffffffff, SDL_FALSE) returns 0 (no error) */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(1, (Uint64)0xffffffffffffffffULL, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters (1,0xffffffffffffffff,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xfffffffffffffffe, SDL_FALSE) returns 0xffffffffffffffff (no error) */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(0, (Uint64)0xfffffffffffffffeULL, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == (Uint64)0xffffffffffffffffULL,
    "Validate result value for parameters (0,0xfffffffffffffffe,SDL_FALSE); expected: 0xffffffffffffffff, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomUintXBoundaryValue(0, 0xffffffffffffffff, SDL_FALSE) returns 0 (sets error) */
  uresult = (Uint64)SDLTest_RandomUint64BoundaryValue(0, (Uint64)0xffffffffffffffffULL, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomUint64BoundaryValue");
  SDLTest_AssertCheck(
    uresult == 0,
    "Validate result value for parameters(0,0xffffffffffffffff,SDL_FALSE); expected: 0, got: %"SDL_PRIs64, uresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Sint8
 */
int
sdltest_randomBoundaryNumberSint8(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Sint64 sresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomSintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12 || sresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 0 || sresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(SCHAR_MIN, 99, SDL_FALSE) returns 100 */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(SCHAR_MIN, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 100,
    "Validate result value for parameters (SCHAR_MIN,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(SCHAR_MIN + 1, SCHAR_MAX, SDL_FALSE) returns SCHAR_MIN (no error) */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(SCHAR_MIN + 1, SCHAR_MAX, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == SCHAR_MIN,
    "Validate result value for parameters (SCHAR_MIN + 1,SCHAR_MAX,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, SCHAR_MIN, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(SCHAR_MIN, SCHAR_MAX - 1, SDL_FALSE) returns SCHAR_MAX (no error) */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(SCHAR_MIN, SCHAR_MAX -1, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == SCHAR_MAX,
    "Validate result value for parameters (SCHAR_MIN,SCHAR_MAX - 1,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, SCHAR_MAX, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(SCHAR_MIN, SCHAR_MAX, SDL_FALSE) returns SCHAR_MIN (sets error) */
  sresult = (Sint64)SDLTest_RandomSint8BoundaryValue(SCHAR_MIN, SCHAR_MAX, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint8BoundaryValue");
  SDLTest_AssertCheck(
    sresult == SCHAR_MIN,
    "Validate result value for parameters(SCHAR_MIN,SCHAR_MAX,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, SCHAR_MIN, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Sint16
 */
int
sdltest_randomBoundaryNumberSint16(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Sint64 sresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomSintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12 || sresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 0 || sresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(SHRT_MIN, 99, SDL_FALSE) returns 100 */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(SHRT_MIN, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 100,
    "Validate result value for parameters (SHRT_MIN,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(SHRT_MIN + 1, SHRT_MAX, SDL_FALSE) returns SHRT_MIN (no error) */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(SHRT_MIN + 1, SHRT_MAX, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == SHRT_MIN,
    "Validate result value for parameters (SHRT_MIN+1,SHRT_MAX,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, SHRT_MIN, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(SHRT_MIN, SHRT_MAX - 1, SDL_FALSE) returns SHRT_MAX (no error) */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(SHRT_MIN, SHRT_MAX - 1, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == SHRT_MAX,
    "Validate result value for parameters (SHRT_MIN,SHRT_MAX - 1,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, SHRT_MAX, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(SHRT_MIN, SHRT_MAX, SDL_FALSE) returns 0 (sets error) */
  sresult = (Sint64)SDLTest_RandomSint16BoundaryValue(SHRT_MIN, SHRT_MAX, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint16BoundaryValue");
  SDLTest_AssertCheck(
    sresult == SHRT_MIN,
    "Validate result value for parameters(SHRT_MIN,SHRT_MAX,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, SHRT_MIN, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Sint32
 */
int
sdltest_randomBoundaryNumberSint32(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Sint64 sresult;
#if ((ULONG_MAX) == (UINT_MAX))
  Sint32 long_min = LONG_MIN;
  Sint32 long_max = LONG_MAX;
#else
  Sint32 long_min = INT_MIN;
  Sint32 long_max = INT_MAX;
#endif

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomSintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12 || sresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 0 || sresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(LONG_MIN, 99, SDL_FALSE) returns 100 */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(long_min, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 100,
    "Validate result value for parameters (LONG_MIN,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(LONG_MIN + 1, LONG_MAX, SDL_FALSE) returns LONG_MIN (no error) */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(long_min + 1, long_max, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == long_min,
    "Validate result value for parameters (LONG_MIN+1,LONG_MAX,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, long_min, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(LONG_MIN, LONG_MAX - 1, SDL_FALSE) returns LONG_MAX (no error) */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(long_min, long_max - 1, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == long_max,
    "Validate result value for parameters (LONG_MIN,LONG_MAX - 1,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, long_max, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(LONG_MIN, LONG_MAX, SDL_FALSE) returns 0 (sets error) */
  sresult = (Sint64)SDLTest_RandomSint32BoundaryValue(long_min, long_max, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint32BoundaryValue");
  SDLTest_AssertCheck(
    sresult == long_min,
    "Validate result value for parameters(LONG_MIN,LONG_MAX,SDL_FALSE); expected: %d, got: %"SDL_PRIs64, long_min, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/*
 * @brief Calls to random boundary number generators for Sint64
 */
int
sdltest_randomBoundaryNumberSint64(void *arg)
{
  const char *expectedError = "That operation is not supported";
  char *lastError;
  Sint64 sresult;

  /* Clean error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  /* RandomSintXBoundaryValue(10, 10, SDL_TRUE) returns 10 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10,
    "Validate result value for parameters (10,10,SDL_TRUE); expected: 10, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 11, SDL_TRUE) returns 10, 11 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 11, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11,
    "Validate result value for parameters (10,11,SDL_TRUE); expected: 10|11, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 12, SDL_TRUE) returns 10, 11, 12 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 12, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12,
    "Validate result value for parameters (10,12,SDL_TRUE); expected: 10|11|12, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 13, SDL_TRUE) returns 10, 11, 12, 13 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 13, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 12 || sresult == 13,
    "Validate result value for parameters (10,13,SDL_TRUE); expected: 10|11|12|13, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(10, 20, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(10, 20, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (10,20,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(20, 10, SDL_TRUE) returns 10, 11, 19 or 20 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(20, 10, SDL_TRUE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 10 || sresult == 11 || sresult == 19 || sresult == 20,
    "Validate result value for parameters (20,10,SDL_TRUE); expected: 10|11|19|20, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(1, 20, SDL_FALSE) returns 0, 21 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(1, 20, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 0 || sresult == 21,
    "Validate result value for parameters (1,20,SDL_FALSE); expected: 0|21, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(LLONG_MIN, 99, SDL_FALSE) returns 100 */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN, 99, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == 100,
    "Validate result value for parameters (LLONG_MIN,99,SDL_FALSE); expected: 100, got: %"SDL_PRIs64, sresult);

  /* RandomSintXBoundaryValue(LLONG_MIN + 1, LLONG_MAX, SDL_FALSE) returns LLONG_MIN (no error) */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN + 1, INT64_MAX, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == INT64_MIN,
    "Validate result value for parameters (LLONG_MIN+1,LLONG_MAX,SDL_FALSE); expected: %"SDL_PRIs64", got: %"SDL_PRIs64, INT64_MIN, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(LLONG_MIN, LLONG_MAX - 1, SDL_FALSE) returns LLONG_MAX (no error) */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN, INT64_MAX - 1, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == INT64_MAX,
    "Validate result value for parameters (LLONG_MIN,LLONG_MAX - 1,SDL_FALSE); expected: %"SDL_PRIs64", got: %"SDL_PRIs64, INT64_MAX, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError == NULL || lastError[0] == '\0', "Validate no error message was set");

  /* RandomSintXBoundaryValue(LLONG_MIN, LLONG_MAX, SDL_FALSE) returns 0 (sets error) */
  sresult = (Sint64)SDLTest_RandomSint64BoundaryValue(INT64_MIN, INT64_MAX, SDL_FALSE);
  SDLTest_AssertPass("Call to SDLTest_RandomSint64BoundaryValue");
  SDLTest_AssertCheck(
    sresult == INT64_MIN,
    "Validate result value for parameters(LLONG_MIN,LLONG_MAX,SDL_FALSE); expected: %"SDL_PRIs64", got: %"SDL_PRIs64, INT64_MIN, sresult);
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/**
 * @brief Calls to SDLTest_RandomIntegerInRange
 */
int
sdltest_randomIntegerInRange(void *arg)
{
  Sint32 min, max;
  Sint32 result;
#if ((ULONG_MAX) == (UINT_MAX))
  Sint32 long_min = LONG_MIN;
  Sint32 long_max = LONG_MAX;
#else
  Sint32 long_min = INT_MIN;
  Sint32 long_max = INT_MAX;
#endif

  /* Standard range */
  min = (Sint32)SDLTest_RandomSint16();
  max = min + (Sint32)SDLTest_RandomUint8() + 2;
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(min,max)");
  SDLTest_AssertCheck(min <= result && result <= max, "Validated returned value; expected: [%d,%d], got: %d", min, max, result);

  /* One Range */
  min = (Sint32)SDLTest_RandomSint16();
  max = min + 1;
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(min,min+1)");
  SDLTest_AssertCheck(min <= result && result <= max, "Validated returned value; expected: [%d,%d], got: %d", min, max, result);

  /* Zero range */
  min = (Sint32)SDLTest_RandomSint16();
  max = min;
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(min,min)");
  SDLTest_AssertCheck(min == result, "Validated returned value; expected: %d, got: %d", min, result);

  /* Zero range at zero */
  min = 0;
  max = 0;
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(0,0)");
  SDLTest_AssertCheck(result == 0, "Validated returned value; expected: 0, got: %d", result);

  /* Swapped min-max */
  min = (Sint32)SDLTest_RandomSint16();
  max = min + (Sint32)SDLTest_RandomUint8() + 2;
  result = SDLTest_RandomIntegerInRange(max, min);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(max,min)");
  SDLTest_AssertCheck(min <= result && result <= max, "Validated returned value; expected: [%d,%d], got: %d", min, max, result);

  /* Range with min at integer limit */
  min = long_min;
  max = long_max + (Sint32)SDLTest_RandomSint16();
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(SINT32_MIN,...)");
  SDLTest_AssertCheck(min <= result && result <= max, "Validated returned value; expected: [%d,%d], got: %d", min, max, result);

  /* Range with max at integer limit */
  min = long_min - (Sint32)SDLTest_RandomSint16();
  max = long_max;
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(...,SINT32_MAX)");
  SDLTest_AssertCheck(min <= result && result <= max, "Validated returned value; expected: [%d,%d], got: %d", min, max, result);

  /* Full integer range */
  min = long_min;
  max = long_max;
  result = SDLTest_RandomIntegerInRange(min, max);
  SDLTest_AssertPass("Call to SDLTest_RandomIntegerInRange(SINT32_MIN,SINT32_MAX)");
  SDLTest_AssertCheck(min <= result && result <= max, "Validated returned value; expected: [%d,%d], got: %d", min, max, result);

  return TEST_COMPLETED;
}

/**
 * @brief Calls to SDLTest_RandomAsciiString
 */
int
sdltest_randomAsciiString(void *arg)
{
  char* result;
  size_t len;
  int nonAsciiCharacters;
  size_t i;

  result = SDLTest_RandomAsciiString();
  SDLTest_AssertPass("Call to SDLTest_RandomAsciiString()");
  SDLTest_AssertCheck(result != NULL, "Validate that result is not NULL");
  if (result != NULL) {
     len = SDL_strlen(result);
     SDLTest_AssertCheck(len >= 1 && len <= 255, "Validate that result length; expected: len=[1,255], got: %d", (int) len);
     nonAsciiCharacters = 0;
     for (i=0; i<len; i++) {
       if (SDL_iscntrl(result[i])) {
         nonAsciiCharacters++;
       }
     }
     SDLTest_AssertCheck(nonAsciiCharacters == 0, "Validate that result does not contain non-Ascii characters, got: %d", nonAsciiCharacters);
     if (nonAsciiCharacters) {
        SDLTest_LogError("Invalid result from generator: '%s'", result);
     }
     SDL_free(result);
  }

  return TEST_COMPLETED;
}


/**
 * @brief Calls to SDLTest_RandomAsciiStringWithMaximumLength
 */
int
sdltest_randomAsciiStringWithMaximumLength(void *arg)
{
  const char* expectedError = "Parameter 'maxLength' is invalid";
  char* lastError;
  char* result;
  size_t targetLen;
  size_t len;
  int nonAsciiCharacters;
  size_t i;

  targetLen = 16 + SDLTest_RandomUint8();
  result = SDLTest_RandomAsciiStringWithMaximumLength((int) targetLen);
  SDLTest_AssertPass("Call to SDLTest_RandomAsciiStringWithMaximumLength(%d)", (int) targetLen);
  SDLTest_AssertCheck(result != NULL, "Validate that result is not NULL");
  if (result != NULL) {
     len = SDL_strlen(result);
     SDLTest_AssertCheck(len >= 1 && len <= targetLen, "Validate that result length; expected: len=[1,%d], got: %d", (int) targetLen, (int) len);
     nonAsciiCharacters = 0;
     for (i=0; i<len; i++) {
       if (SDL_iscntrl(result[i])) {
         nonAsciiCharacters++;
       }
     }
     SDLTest_AssertCheck(nonAsciiCharacters == 0, "Validate that result does not contain non-Ascii characters, got: %d", nonAsciiCharacters);
     if (nonAsciiCharacters) {
        SDLTest_LogError("Invalid result from generator: '%s'", result);
     }
     SDL_free(result);
  }

  /* Negative test */
  targetLen = 0;
  result = SDLTest_RandomAsciiStringWithMaximumLength((int) targetLen);
  SDLTest_AssertPass("Call to SDLTest_RandomAsciiStringWithMaximumLength(%d)", (int) targetLen);
  SDLTest_AssertCheck(result == NULL, "Validate that result is NULL");
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}

/**
 * @brief Calls to SDLTest_RandomAsciiStringOfSize
 */
int
sdltest_randomAsciiStringOfSize(void *arg)
{
  const char* expectedError = "Parameter 'size' is invalid";
  char* lastError;
  char* result;
  size_t targetLen;
  size_t len;
  int nonAsciiCharacters;
  size_t i;

  /* Positive test */
  targetLen = 16 + SDLTest_RandomUint8();
  result = SDLTest_RandomAsciiStringOfSize((int) targetLen);
  SDLTest_AssertPass("Call to SDLTest_RandomAsciiStringOfSize(%d)", (int) targetLen);
  SDLTest_AssertCheck(result != NULL, "Validate that result is not NULL");
  if (result != NULL) {
     len = SDL_strlen(result);
     SDLTest_AssertCheck(len == targetLen, "Validate that result length; expected: len=%d, got: %d", (int) targetLen, (int) len);
     nonAsciiCharacters = 0;
     for (i=0; i<len; i++) {
       if (SDL_iscntrl(result[i])) {
         nonAsciiCharacters++;
       }
     }
     SDLTest_AssertCheck(nonAsciiCharacters == 0, "Validate that result does not contain non-ASCII characters, got: %d", nonAsciiCharacters);
     if (nonAsciiCharacters) {
        SDLTest_LogError("Invalid result from generator: '%s'", result);
     }
     SDL_free(result);
  }

  /* Negative test */
  targetLen = 0;
  result = SDLTest_RandomAsciiStringOfSize((int) targetLen);
  SDLTest_AssertPass("Call to SDLTest_RandomAsciiStringOfSize(%d)", (int) targetLen);
  SDLTest_AssertCheck(result == NULL, "Validate that result is NULL");
  lastError = (char *)SDL_GetError();
  SDLTest_AssertPass("SDL_GetError()");
  SDLTest_AssertCheck(lastError != NULL && SDL_strcmp(lastError, expectedError) == 0,
             "SDL_GetError(): expected message '%s', was message: '%s'",
             expectedError,
             lastError);

  /* Clear error messages */
  SDL_ClearError();
  SDLTest_AssertPass("SDL_ClearError()");

  return TEST_COMPLETED;
}


/* ================= Test References ================== */

/* SDL_test test cases */
static const SDLTest_TestCaseReference sdltestTest1 =
        { (SDLTest_TestCaseFp)sdltest_getFuzzerInvocationCount, "sdltest_getFuzzerInvocationCount", "Call to sdltest_GetFuzzerInvocationCount", TEST_ENABLED };

static const SDLTest_TestCaseReference sdltestTest2 =
        { (SDLTest_TestCaseFp)sdltest_randomNumber, "sdltest_randomNumber", "Calls to random number generators", TEST_ENABLED };

static const SDLTest_TestCaseReference sdltestTest3 =
        { (SDLTest_TestCaseFp)sdltest_randomBoundaryNumberUint8, "sdltest_randomBoundaryNumberUint8", "Calls to random boundary numbe